{
  "job": "프론트엔드 개발자",
  "name": "김우석",
  "introduce": "안녕하세요? 기록, UX, 자동화를 추구하는 개발자입니다.<br />유저에게 최대의 경험을 줄 수 있어야 한다고 생각하기에 사용자 중심 디자인과 직관적인 인터페이스 구현 및 최적화에 집중합니다.<br />리눅스 클라우드 환경에서 Nginx를 이용한 도메인 작업 및 SSL 환경을 포함한 배포가 가능합니다.<br />과정에서 Github actions를 통해 자동 배포 스크립트를 작성할 수 있으며, 크론탭을 통해 주기 반복 소프트웨어 제작 경험이 있습니다.",
  "title": "개발 경력",
  "time": "총 2년 2개월",
  "careers": [
    {
      "company": "빌리버",
      "company-info": "WebXR 메타버스, AI 웹툰 플랫폼",
      "position": "직책",
      "list": [
        {
          "title": "Three JS + WebRTC 화상 통화 솔루션 개발",
          "contents": [
            "당시 메타버스 핵심 VR 헤드셋 사용자에게 새로운 통화 경험을 제공하기 위해 React, Nestjs, Three JS, Typescript를 사용한 솔루션 개발. 송 수신자 관계가 1:N인 오픈소스 라이브러리를 수정하여 1:1 최적화 라이브러리로 전환 함. 비트레이트 개선율 약 166% (1500 -> 4000)kbps 달성함. 이후 제품을 메타버스 엑스포, 82 Startup 전시"
          ]
        },
        {
          "title": "AI 웹툰 플랫폼 서비스 프론트 개발",
          "contents": [
            "플랫폼 서비스 프론트엔드 개발, 배포, API 설계 및 일정 관리 업무를 진행. 모바일 최적화 웹앱을 만드는 것을 목표. 유저가 이용하는 프론트를 작업했으며, 백오피스 작업을 지원. 많은 양의 이미지의 자연스러운 노출을 위해 Intersection Observer를 사용해서 무한 스크롤을 적용 및 다국어 지원 및 IP 기반 국적 확인 기능들을 개발",
            "백엔드 API 설계 참여, 네이버 클라우드 서버 관리, Docker, Shell scripts를 사용한 배포 프로세스 작성. 도커 이미지 최적화로 1.97GB -> 1.03GB 이미지 사이즈 48% 축소"
          ]
        },
        {
          "title": "Mozilla hubs(React 3D 메타버스 공간), Spoke(React 3D 메타버스 공간 제작 툴) 오픈 소스 라이브러리 기능 추가 및 리팩토링",
          "contents": [
            "XR 공간 제작 툴 Mozilla hubs, spoke를 사용중인 사내 디자인 팀을 위해 추가 기능 작업 및 기존 에러로 사용되지 않고 있던 Spoke의 Asset Store기능 복원. 다국어 지원 기능 추가 및 위치 기반 3D 컴포넌트를 추가해서 유저가 glft를 교체하면 실시간으로 에셋이 변경되는 컴포넌트 제작"
          ]
        },
        {
          "title": "Mozilla hubs Elixir 기반 서버 API 작업 및 짐벌락 에러 해결",
          "contents": [
            "Spoke(React 3D 메타버스 공간 제작 툴)를 사용하지 않고 gltf 파일과 컴포넌트 ID, Z값 만으로 해당 컴포넌트의 3D Asset을 변경시키는 기능 추가. 작업 중 3D 컴포넌트가 180도 뒤집어져 생성이 되는 에러 발견. 이 에러는 기존 spoke에서 오일러 각을 기반 컴포넌트를 저장할 때는 쿼터니안 각으로 저장하기 때문에 발생한 문제. 오일러 각을 쿼터니안 각으로 변경시키는 함수 추가 후 문제 해결."
          ]
        }
      ]
    }
  ],
  "portfolio": {
    "title": "포트폴리오",
    "list": [
      {
        "title": "Doke (도케)",
        "source": "https://github.com/vvsogi/doke",
        "badges": ["nextjs", "nestjs", "typescript", "jest", "docker", "shell"],
        "description": "RESTful API 자동 문서화 오픈소스 라이브러리",
        "images": {
          "grid": 2,
          "list": [
            { "url": "images/doke/doke-example.png", "alt": "Doke" },
            { "url": "images/doke/swagger-example.png", "alt": "Swagger" }
          ]
        },
        "contents": [
          "Doke는 RESTful API 자동 문서화를 목표로 탄생한 라이브러리입니다. 비슷한 라이브러리로 Swagger가 있습니다. 회사간 API 문서 전달 과정에서 Swagger의 UI 측면의 부족함을 느끼고 이를 대체할만한 자동 문서화 도구의 필요성을 감지했고, 이를 직접 제작했습니다. 해당 라이브러리는 Nest JS의 Custom Decorator와 Nest js의 DiscoveryModule을 사용해서 문서 제작에 필요한 데이터들을 자동으로 수집합니다. 사용자는 각 엔드포인트의 설명 및 Request Parameter에 대한 설명만을 작성하고 명령어를 실행하면 외부 공개에 유리한 디자인을 가진 API Docs 페이지를 얻을 수 있습니다.",
          "Swagger는 강조하고 싶은 UI가 있을 때 이를 수정하기 어렵지만, Doke를 사용한다면 어렵지 않습니다. doke-ui package를 클론 한 후 원하는 UI로 커스터마이징 할 수 있습니다.",
          "해당 라이브러리는 DX를 높이기 위해 UI 빌드 및 배포에 대한 CLI 패키지를 제작 및 배포되어 있습니다. doke-nest를 통해 JSON 문서를 얻었다면 이를 기반으로 최적화된 웹앱을 빌드합니다. Next js의 standalone 모드를 기반으로 빌드하기 때문에 기존 웹앱들의 Docker image 용량이 1GB ~ 2GB인 반면, doke-ui의 이미지 파일은 182MB로 약 10배 가볍습니다.",
          "doke-nest의 모든 모듈은 Jest를 통해 테스트 작성 및 통과했으며 안정성을 검증했습니다."
        ]
      },
      {
        "title": "Todolist remake",
        "source": "https://github.com/VVSOGI/todolist-remake",
        "badges": ["nextjs", "tailwind", "nestjs", "typia", "typescript", "jest", "docker", "shell"],
        "description": "모노 레포지토리 투두리스트 웹앱",
        "images": {
          "grid": 3,
          "list": [
            { "url": "images/todolist/todolist-1.png", "alt": "todolist-1" },
            { "url": "images/todolist/todolist-2.png", "alt": "todolist-2" },
            { "url": "images/todolist/todolist-3.png", "alt": "todolist-3" },
            { "url": "images/todolist/todolist-4.png", "alt": "todolist-4" },
            { "url": "images/todolist/todolist-5.png", "alt": "todolist-5" }
          ]
        },
        "contents": [
          "'개발자는 이전에 만들었던 프로젝트를 한 번 다시 만들어보는 경험이 중요하다.' 투두리스트 웹앱은 스스로의 실력 평가를 위해서 종종 제작하는 프로젝트입니다. 이번 투두리스트는 2024년 말에 제작했으며, yarn을 활용한 모노 레포지토리 입니다. 프론트엔드는 Storybook을 활용한 컴포넌트 테스트 코드, 백엔드는 Jest + typia를 활용해 유닛 테스트를 더 엄격하게 적용했습니다.",
          "Typia는 빌드 이후에도 실시간으로 타입을 체크할 수 있는 라이브러리입니다. 해당 라이브러리를 도입한 계기는 DTO를 검증하는 validator를 테스트 용도와 실제 사용 용도로 나누지 않고 단일 객체로 사용하기 위함입니다. 기존 테스트는 테스트 예시와 결과를 모두 결정해놓고 그 사이의 코드를 작성하는 방식입니다. 그 코드의 결과가 나오게끔 작성하면 되기 때문에 테스트로써 가치 및 신뢰성이 저하됩니다. 실제 유저에게 데이터를 받아 코드의 검증을 진행하는 객체 타겟으로 테스트하며 해당 검증 객체의 엣지 케이스를 채울 수 있게 하는 것이 진짜 테스트 코드라고 생각하기에 이를 Typia를 통해 구현했습니다.",
          "실제 동작하는 DTO 검증 객체에 대한 테스트와 엣지 케이스에 해당하는 테스트 케이스를 검증했으며, 그 결과 41개의 테스트 케이스를 더 엄격하게 검증했습니다. 테스트 케이스가 늘어갈수록 서버 동작의 신뢰성은 상승하기에 갯수와 서버 동작의 안정성은 선형적 상승 비례 관계를 가지고 있습니다.",
          "서버에는 PlantUML을 통해 엔드포인트간 API 프로세스의 진행 과정을 작성했습니다.",
          "프론트엔드는 프로젝트의 규모가 커짐에 따라 증가하는 전체 사이즈와 스토리북과의 컴포넌트 공유 문제를 해결하기 위해 중복되는 코드를 패키지로 만들어서 관리하게 됐습니다. 위의 과정에서 많은 양의 코드가 분리되었기에 프론트엔드 도커 빌드 시간을 38.6% 감소시킬 수 있었습니다.",
          "Next js에서 Presenter Container 패턴을 효율적으로 사용하기 위해 각 페이지에 대표되는 Display라는 Presenter를 만들었고, 서버에서 데이터를 받아 가공해야할 상황에는 custom hooks를 Container로써 사용했습니다. 최대한 Presenter에서는 데이터를 전달받는다는 의존만을 가지게 작성했습니다.",
          "Frontend, Backend, DB, Stories 서버들을 모두 Docker 컨테이너로 관리하고 있습니다. 좀 더 효율적인 사용을 위해 shell scripts와 docker-compose를 사용해 명령어 한번으로 각 서버를 빌드 배포할 수 있는 자동화 작업이 되어있습니다."
        ]
      },
      {
        "title": "Picture In Picture From Korea Extension",
        "source": "https://github.com/VVSOGI/picture-in-picture-from-korea",
        "badges": ["chromeExtension", "Javascript"],
        "description": "Google Picture-in-Picture Extension 기능 확장 버전",
        "images": {
          "grid": 2,
          "list": [
            { "url": "images/pip/pip-1.png", "alt": "Promo image" },
            { "url": "images/pip/pip-2.gif", "alt": "어떤 탭에서도 Alt + P로 자유롭게" }
          ]
        },
        "contents": [
          "기존에 있던 Google Picture-in-Picture Extension의 기능 확장 버전입니다. Google Picture-in-Picture Extension은 선택한 탭 내부에서만 단축키가 입력이 가능하여 PIP 모드 전환의 접근성이 낮다는 점에 감안하여 수정해서 배포했습니다.",
          "해당 문제를 해결하기 위해서 tab, storage permissions을 추가로 확보하여 다른 탭에 대한 접근 데이터를 가져왔고, storage를 사용하여 Picture-in-Picture 모드를 사용중인 탭에 대한 데이터를 저장 및 수정할 수 있도록 바꿨습니다. tab에 대한 권한은 보안적인 위험 요소가 있기에 크롬 웹스토어에서 해당 익스텐션에 대한 주의를 필요로 하기 때문에 소스를 공개하였고 Picture-In-Picture 모드로 전환할 수 있는 사이트에 제한을 걸었습니다.",
          "크롬 웹스토어에 배포에 필요한 모든 이미지는 직접 Figma를 통해 제작한 이미지입니다.",
          "간단하게 코드가 작성되어 있지만 이전 익스텐션보다 훨씬 뛰어난 사용성을 보여주는 익스텐션입니다."
        ]
      }
    ]
  }
}
