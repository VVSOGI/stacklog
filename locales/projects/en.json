{
  "list": [
    {
      "page": "doke",
      "title": "Doke",
      "source": "https://github.com/vvsogi/doke",
      "badges": ["nextjs", "nestjs", "typescript", "jest", "docker", "shell"],
      "description": "Open source library for auto-documenting RESTful APIs",
      "motivate": "Let's build a self-documenting open source library that goes beyond Swagger!",
      "images": {
        "grid": 2,
        "list": [
          { "url": "/images/doke/doke-example-1.png", "alt": "Doke" },
          { "url": "/images/doke/doke-example.png", "alt": "Doke" },
          { "url": "/images/doke/swagger-example.png", "alt": "Swagger" }
        ]
      },
      "contents": [
        "Doke is a library that aims to automatically document RESTful APIs. A similar library is Swagger. While communicating API documentation between companies, we realized the lack of UI aspects of Swagger and saw the need for an alternative automated documentation tool, so we built it ourselves. The library uses Nest JS's Custom Decorator and Nest js's DiscoveryModule to automatically collect the data needed to create documentation. The user only needs to write a description of each endpoint and Request Parameters and run the command to get an API Docs page with a design favorable for external publication",
        "Swagger is hard to modify when you have a UI you want to emphasize, but with Doke, it's not hard: you can clone the doke-ui package and customize it with the UI you want",
        "The library has CLI packages for building and deploying UI to increase DX. Once you get the JSON documentation via doke-nest, build an optimized webapp based on it. Since we build based on the standalone mode of Next js, the image file of doke-ui is about 10 times lighter at 182MB, while the Docker image of traditional webapps is 1GB to 2GB in size",
        "All modules in doke-nest have been written and passed tests with Jest and verified for stability."
      ],
      "createdAt": "2025-04-25"
    },
    {
      "page": "todolist",
      "title": "Todolist remake",
      "source": "https://github.com/VVSOGI/todolist-remake",
      "badges": ["nextjs", "tailwind", "nestjs", "typia", "typescript", "jest", "docker", "shell"],
      "description": "Mono repository todolist web app",
      "motivate": "Implement a periodic code proficiency validation and rigorous testing environment",
      "images": {
        "grid": 3,
        "list": [
          { "url": "/images/todolist/todolist-6.png", "alt": "category-1" },
          { "url": "/images/todolist/todolist-1.png", "alt": "todolist-1" },
          { "url": "/images/todolist/todolist-2.png", "alt": "todolist-2" },
          { "url": "/images/todolist/todolist-3.png", "alt": "todolist-3" },
          { "url": "/images/todolist/todolist-4.png", "alt": "todolist-4" },
          { "url": "/images/todolist/todolist-5.png", "alt": "todolist-5" }
        ]
      },
      "contents": [
        "'It's important for developers to have the experience of recreating a project they've made before.' Toodoo List web apps are often made to evaluate their skills. This Toodoo List was made in late 2024 and is a mono-repository using yarn. We used Storybook for component test code on the frontend and Jest + typia on the backend for more rigorous unit testing",
        "Typia is a library that allows you to type check in real-time, even after build. The idea behind this library is to use the validator that validates our DTOs as a single object instead of splitting it between testing and production use. In traditional testing, you decide both the test example and the outcome, and then write the code between them, which reduces the value and reliability of the test because you only need to write the code to produce the outcome. We believe that real test code is when you test against an object target that takes data from real users, validates your code, and allows them to fill in the edge cases of that validation object, and that's what we've done with Typia",
        "We validated the tests against the actual working DTO validation objects and the test cases corresponding to the edge cases, which resulted in 41 more rigorous test cases. As the number of test cases increases, the reliability of the server behavior increases, so there is a linear upward proportional relationship between the number and the reliability of the server behavior",
        "On the server, we wrote the progression of the API process between endpoints via PlantUML",
        "The frontend was managed by packaging redundant code to address the increasing overall size of the project and the issue of component sharing with storybooks. The above process decoupled a large amount of code, which resulted in a 38.6% reduction in frontend docker build time.",
        "To efficiently use the Presenter Container pattern in Next js, I created a Presenter called Display that is represented on each page, and used custom hooks as Containers in situations where I needed to receive and process data from the server. As much as possible, I wrote the Presenter to only rely on receiving data.",
        "Frontend, Backend, DB, and Stories servers are all managed as Docker containers. To make it more efficient, I've automated the build deployment of each server with a single command using shell scripts and docker-compose."
      ],
      "createdAt": "2025-04-25"
    },
    {
      "page": "pip",
      "title": "Picture In Picture From Korea Extension",
      "source": "https://github.com/VVSOGI/picture-in-picture-from-korea",
      "badges": ["chromeExtension", "Javascript"],
      "description": "Extended version of Google Picture-in-Picture Extension",
      "motivate": "Google Picture-in-Picture Extension could be better with tabs and storage",
      "images": {
        "grid": 2,
        "list": [
          { "url": "/images/pip/pip-2.gif", "alt": "Free change to Alt + P in any tab" },
          { "url": "/images/pip/pip-1.png", "alt": "Promo image" }
        ]
      },
      "contents": [
        "This is a feature-extended version of the existing Google Picture-in-Picture Extension. The Google Picture-in-Picture Extension was modified and deployed in response to the inaccessibility of switching PIP mode because the shortcut key can only be entered from inside the selected tab.",
        "To fix this issue, we added the TAB and stroage permissions to get access data for other tabs, and changed the way stroage is used to store and modify data for tabs that are using Picture-in-Picture mode. Because the permissions on TAB pose a security risk and require caution with this extension on the Chrome Web Store, we have released the source and placed restrictions on the sites that can switch to Picture-in-Picture mode.",
        "All images required for deployment on the Chrome Web Store were created by hand using Figma",
        "This extension is simply coded, but has much better usability than previous extensions."
      ],
      "createdAt": "2025-04-25"
    },
    {
      "page": "sniff",
      "title": "Sniff & Step",
      "source": "https://github.com/Minthug/Sniff-Step",
      "badges": ["nextjs", "tailwind", "typescript", "docker", "shell", "aws"],
      "description": "Neighborhood-based dog walking platform",
      "motivate": "Let's create a platform for busy people who can't find time to walk their dogs",
      "images": {
        "grid": 2,
        "list": [
          { "url": "/images/sniff/sniff-4.png", "alt": "main" },
          { "url": "/images/sniff/sniff-1.png", "alt": "main" },
          { "url": "/images/sniff/sniff-2.png", "alt": "onboarding" },
          { "url": "/images/sniff/sniff-3.png", "alt": "architecture" }
        ]
      },
      "contents": [
        "This is a team project with two front and backend developers. We collaborated on the planning and initial API design, and I took the design work and front-end lead using Pygma",
        "We improved the UX by using KAKAO Maps API for location-based service development, optimizing responsive design according to devices, and introducing Google SSO for membership signup and login. We received a green good score in Lighthouse's webpage quality measurement",
        "We built a multilingual support system through middleware to ensure that the service is not limited to Koreans",
        "We used Next js own server as a BFF server when requesting APIs from the front to the backend. This allows the backend to work on purely business logic-related tasks and avoids CORS errors. Also, third-party APIs can be accessed from the Next server, so we actively utilized the Next server.",
        "The deployment was done through AWS, and we built the system so that we could deploy the frontend with a single line of command in the cloud environment via Docker and shell scripts."
      ],
      "createdAt": "2025-04-25"
    }
  ]
}
