{
  "list": [
    {
      "page": "doke",
      "title": "Doke (도케)",
      "source": "https://github.com/vvsogi/doke",
      "badges": ["nextjs", "nestjs", "typescript", "jest", "docker", "shell"],
      "description": "RESTful API 자동 문서화 오픈소스 라이브러리",
      "motivate": "Swagger를 뛰어넘는 자동 문서화 오픈소스 라이브러리를 제작해보자",
      "images": {
        "grid": 2,
        "list": [
          { "url": "/images/doke/doke-example-1.png", "alt": "Doke" },
          { "url": "/images/doke/doke-example.png", "alt": "Doke" },
          { "url": "/images/doke/swagger-example.png", "alt": "Swagger" }
        ]
      },
      "contents": [
        "Doke는 RESTful API 자동 문서화를 목표로 탄생한 라이브러리입니다. 비슷한 라이브러리로 Swagger가 있습니다. 회사간 API 문서 전달 과정에서 Swagger의 UI 측면의 부족함을 느끼고 이를 대체할만한 자동 문서화 도구의 필요성을 감지했고, 이를 직접 제작했습니다. 해당 라이브러리는 Nest JS의 Custom Decorator와 Nest js의 DiscoveryModule을 사용해서 문서 제작에 필요한 데이터들을 자동으로 수집합니다. 사용자는 각 엔드포인트의 설명 및 Request Parameter에 대한 설명만을 작성하고 명령어를 실행하면 외부 공개에 유리한 디자인을 가진 API Docs 페이지를 얻을 수 있습니다.",
        "Swagger는 강조하고 싶은 UI가 있을 때 이를 수정하기 어렵지만, Doke를 사용한다면 어렵지 않습니다. doke-ui package를 클론 한 후 원하는 UI로 커스터마이징 할 수 있습니다.",
        "해당 라이브러리는 DX를 높이기 위해 UI 빌드 및 배포에 대한 CLI 패키지를 제작 및 배포되어 있습니다. doke-nest를 통해 JSON 문서를 얻었다면 이를 기반으로 최적화된 웹앱을 빌드합니다. Next js의 standalone 모드를 기반으로 빌드하기 때문에 기존 웹앱들의 Docker image 용량이 1GB ~ 2GB인 반면, doke-ui의 이미지 파일은 182MB로 약 10배 가볍습니다.",
        "doke-nest의 모든 모듈은 Jest를 통해 테스트 작성 및 통과했으며 안정성을 검증했습니다."
      ],
      "createdAt": "2025-04-25"
    },
    {
      "page": "todolist",
      "title": "Todolist remake",
      "source": "https://github.com/VVSOGI/todolist-remake",
      "badges": ["nextjs", "tailwind", "nestjs", "typia", "typescript", "jest", "docker", "shell"],
      "description": "모노 레포지토리 투두리스트 웹앱",
      "motivate": "주기적 코드 실력 검증 및 엄격한 테스트 환경 구현해보기",
      "images": {
        "grid": 3,
        "list": [
          { "url": "/images/todolist/todolist-6.png", "alt": "category-1" },
          { "url": "/images/todolist/todolist-1.png", "alt": "category-1" },
          { "url": "/images/todolist/todolist-2.png", "alt": "category-2" },
          { "url": "/images/todolist/todolist-3.png", "alt": "todolist-1" },
          { "url": "/images/todolist/todolist-4.png", "alt": "todolist-2" },
          { "url": "/images/todolist/todolist-5.png", "alt": "testcase" }
        ]
      },
      "contents": [
        "'개발자는 이전에 만들었던 프로젝트를 한 번 다시 만들어보는 경험이 중요하다.' 투두리스트 웹앱은 스스로의 실력 평가를 위해서 종종 제작하는 프로젝트입니다. 이번 투두리스트는 2024년 말에 제작했으며, yarn을 활용한 모노 레포지토리 입니다. 프론트엔드는 Storybook을 활용한 컴포넌트 테스트 코드, 백엔드는 Jest + typia를 활용해 유닛 테스트를 더 엄격하게 적용했습니다.",
        "Typia는 빌드 이후에도 실시간으로 타입을 체크할 수 있는 라이브러리입니다. 해당 라이브러리를 도입한 계기는 DTO를 검증하는 validator를 테스트 용도와 실제 사용 용도로 나누지 않고 단일 객체로 사용하기 위함입니다. 기존 테스트는 테스트 예시와 결과를 모두 결정해놓고 그 사이의 코드를 작성하는 방식입니다. 그 코드의 결과가 나오게끔 작성하면 되기 때문에 테스트로써 가치 및 신뢰성이 저하됩니다. 실제 유저에게 데이터를 받아 코드의 검증을 진행하는 객체 타겟으로 테스트하며 해당 검증 객체의 엣지 케이스를 채울 수 있게 하는 것이 진짜 테스트 코드라고 생각하기에 이를 Typia를 통해 구현했습니다.",
        "실제 동작하는 DTO 검증 객체에 대한 테스트와 엣지 케이스에 해당하는 테스트 케이스를 검증했으며, 그 결과 41개의 테스트 케이스를 더 엄격하게 검증했습니다. 테스트 케이스가 늘어갈수록 서버 동작의 신뢰성은 상승하기에 갯수와 서버 동작의 안정성은 선형적 상승 비례 관계를 가지고 있습니다.",
        "서버에는 PlantUML을 통해 엔드포인트간 API 프로세스의 진행 과정을 작성했습니다.",
        "프론트엔드는 프로젝트의 규모가 커짐에 따라 증가하는 전체 사이즈와 스토리북과의 컴포넌트 공유 문제를 해결하기 위해 중복되는 코드를 패키지로 만들어서 관리하게 됐습니다. 위의 과정에서 많은 양의 코드가 분리되었기에 프론트엔드 도커 빌드 시간을 38.6% 감소시킬 수 있었습니다.",
        "Next js에서 Presenter Container 패턴을 효율적으로 사용하기 위해 각 페이지에 대표되는 Display라는 Presenter를 만들었고, 서버에서 데이터를 받아 가공해야할 상황에는 custom hooks를 Container로써 사용했습니다. 최대한 Presenter에서는 데이터를 전달받는다는 의존만을 가지게 작성했습니다.",
        "Frontend, Backend, DB, Stories 서버들을 모두 Docker 컨테이너로 관리하고 있습니다. 좀 더 효율적인 사용을 위해 shell scripts와 docker-compose를 사용해 명령어 한번으로 각 서버를 빌드 배포할 수 있는 자동화 작업이 되어있습니다."
      ],
      "createdAt": "2025-04-25"
    },
    {
      "page": "pip",
      "title": "Picture In Picture From Korea Extension",
      "source": "https://github.com/VVSOGI/picture-in-picture-from-korea",
      "badges": ["chromeExtension", "Javascript"],
      "description": "Google Picture-in-Picture Extension 기능 확장 버전",
      "motivate": "Google Picture-in-Picture Extension는 tab과 storage를 사용하면 더 발전할 수 있다",
      "images": {
        "grid": 2,
        "list": [
          { "url": "/images/pip/pip-2.gif", "alt": "어떤 탭에서도 Alt + P로 자유롭게" },
          { "url": "/images/pip/pip-1.png", "alt": "Promo image" }
        ]
      },
      "contents": [
        "기존에 있던 Google Picture-in-Picture Extension의 기능 확장 버전입니다. Google Picture-in-Picture Extension은 선택한 탭 내부에서만 단축키가 입력이 가능하여 PIP 모드 전환의 접근성이 낮다는 점에 감안하여 수정해서 배포했습니다.",
        "해당 문제를 해결하기 위해서 tab, storage permissions을 추가로 확보하여 다른 탭에 대한 접근 데이터를 가져왔고, storage를 사용하여 Picture-in-Picture 모드를 사용중인 탭에 대한 데이터를 저장 및 수정할 수 있도록 바꿨습니다. tab에 대한 권한은 보안적인 위험 요소가 있기에 크롬 웹스토어에서 해당 익스텐션에 대한 주의를 필요로 하기 때문에 소스를 공개하였고 Picture-In-Picture 모드로 전환할 수 있는 사이트에 제한을 걸었습니다.",
        "크롬 웹스토어에 배포에 필요한 모든 이미지는 직접 Figma를 통해 제작한 이미지입니다.",
        "간단하게 코드가 작성되어 있지만 이전 익스텐션보다 훨씬 뛰어난 사용성을 보여주는 익스텐션입니다."
      ],
      "createdAt": "2025-04-25"
    },
    {
      "page": "sniff",
      "title": "Sniff & Step",
      "source": "https://github.com/Minthug/Sniff-Step",
      "badges": ["nextjs", "tailwind", "typescript", "docker", "shell", "aws"],
      "description": "동네 기반 반려견 산책 대행 플랫폼",
      "motivate": "반려견 산책 시간을 만들 수 없는 바쁜 현대인을 위한 플랫폼을 만들어보자",
      "images": {
        "grid": 2,
        "list": [
          { "url": "/images/sniff/sniff-4.png", "alt": "main" },
          { "url": "/images/sniff/sniff-1.png", "alt": "main" },
          { "url": "/images/sniff/sniff-2.png", "alt": "onboarding" },
          { "url": "/images/sniff/sniff-3.png", "alt": "architecture" }
        ]
      },
      "contents": [
        "프론트, 백엔드 개발자 두 명의 팀 프로젝트입니다. 기획과 초기 API 설계는 공동으로 작업했고, 피그마를 이용한 디자인 작업 및 프론트엔드 리드를 맡았습니다.",
        "위치 기반 서비스 개발을 위한 KAKAO Maps API, 디바이스에 따른 반응형 디자인 최적화, 회원 가입 및 로그인에 구글 SSO를 도입해 UX를 개선했습니다. Lighthouse의 웹페이지 품질 측정에서 초록색 양호 점수를 받았습니다.",
        "서비스가 한국인으로 국한되지 않게 하기 위해 미들웨어를 통해 다국어 지원 시스템을 구축했습니다.",
        "프론트에서 백엔드로 API를 요청할 때 Next js 자체 서버를 BFF 서버 형식으로 사용했습니다. 이를 통해서 백엔드에서는 순수하게 비즈니스 로직 관련 작업을 할 수 있고, CORS 에러 또한 피할 수 있습니다. 또한 서드 파티 API 또한 Next 서버에서 접근할 수 있기에 Next 서버를 적극적으로 활용했습니다.",
        "배포는 AWS를 통해 진행했으며, 도커와 쉘 스크립트를 통해 클라우드 환경에서 명령어 한 줄로 프론트엔드를 배포할 수 있게 시스템을 구축했습니다."
      ],
      "createdAt": "2025-04-25"
    }
  ]
}
